# Механики

## Здоровье и энергия

У большинства физических объектов есть показатель здоровья. У кораблей также есть энергия.
Энергия восстанавливается со временем и тратится на любые взадействия - ускорение, выстрелы
бесконечным вооружением, получение урона.

При получении урона сначала тратится энергия. Если ее не хватает для поглощения урона, то
остаток отнимается от здоровья.

### Броня и сопротивление энергетического щита

У корабля также есть два раздельных показателя сопротивления урона для здоровья и для энергии.
Первое называется показателем сопротивления брони, второе - сопротивлением энергетического щита:

- Значение в единицу означает отсутствие влияния
- Значение больше единицы - повышенное сопротивление урону
- Значение меньше единицы - пониженное сопротивление урону

У любого вооружения помимо параметра урона есть раздельные параметры пробития брони и щита:

- Значение в единицу означает отсутствие влияния.
- значение больше единицы - повышенное влияние.
- значение меньше единицы - пониженное влияние.

### Механика расчета получаемого урона

#### Исходные данные

```ts
let Sh = 100; // здоровье корабля
let Sp = 25; // энергия корабля
let Ssr = 0.9; // сопротивление уровну для щита
let Shr = 1.1; // сопротивление урону для здоровья

let D = 50; // входящий урон
let Dsp = 1; // коэффициент пробития щитов
let Dhp = 1.2; // коэффициент пробития брони
```

#### Первый вариант расчета

```ts
let shieldDamage = Math.max(0, (D * Dsp) / Ssr);
let powerAfterDamage = Sp - shieldDamage;

Sp = Math.max(0, powerAfterDamage);

let damageAfterShield = 0 - powerAfterDamage;
if (damageAfterShield <= 0) {
  return;
}

let healthDamage = (damageAfterShield * Dhp) / Shr;
let healthAfterDamage = Sh - healthDamage;

Sh = healthAfterDamage;
```

Преимущества:

- Предсказуемый расчет урона

Недостатки:

- Оператор деления в операциях (дорогостоящая операция)

#### Второй вариант расчета

```ts
let modifiedShieldValue = Sp * Ssr - D * Dsp;
let shieldAfterDamage = Math.min(Sp, modifiedShieldValue);

Sp = Math.max(0, shieldAfterDamage);

let damageAfterShield = 0 - shieldAfterDamage;
if (damageAfterShield <= 0) {
  return;
}

let modifiedHealthValue = Sh * Shr - damageAfterShield * Dhp;
let healthAfterDamage = Math.min(Sh, modifiedHealthValue);

Sh = healthAfterDamage;
```

Преимущества:

- Более оптимизированная логика расчета

Недостатки:

- В некоторых условиях значение урона может стать отрицательным,
  поэтому следует убедиться, что подобный урон не применитя
